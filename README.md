# Artificial-intelligence-system
### Курс "Системы искусственного интеллекта" в МГТУ им Баумана

## FAQ по фильтрированному поиску

1. Как запустить?

- Скачиваете [golang](https://golang.org/dl/) версии 1.13 или выше
- Дальше из корневой папки проекта прописываете команду `go run main.go`
- Сайт запустится по адресу [localhost:2997](http://localhost:2997)

2. Как открыть фильтрованный поиск?
- Нажмите на `расширенный поиск`(зеленая кнопка наверху слева под поисковой строкой), откроется 2 панельки. В левой будут двойные ползунки для указания интервалов. В правой панели находятся метки с вариантами типа/возраста/жанров. Кликайте по ним, чтобы убрать/добавить соответсвующий параметр. Если метка засерена, значит все тайтлы, имеющие соответствующий параметр будут исключены из поисковой выдачи.  

3. Как применить фильтры?
- Они применяются автоматически сразу после изменения параметров

4. А что будет, если выставить фильтры так, чтобы ни одного тайтла не нашлось?
- Выведется сообщение: Нет тайтлов, удовлетворяющих выбранным условиям. Но мы подобрали небольшой список того, что может вам понравиться:
- Чуть ниже выведутся список рекомендуемых тайтлов

5. Как выбирается какие тайтлы посоветовать?
  - Я делю поисковые фильтры на 2 типа:
    - Постоянные фильтры - такие фильтры, которые __запрещно менять__. Например пользователь указал, что хочет смотреть только комедию, система гарантирует, что все рекомендоманные тайтлы будут являться комедиями. К таким фильтрам относятся: 
        - тип тайтла;
        - возрастной рейтинг;
        - онгоинг;
        - студия;
        - жанр.
    - Плавающие фильтры - фильтры, рамки которых можно сдвигать, что приводит к появлению рекомендаций. К ним относятся все интервальные фильтры:
        - Пользовательская оценка
        - Эпизоды
        - Длительность
        - Год выпуска
    - Особняком стоит поиск по тексту, по сути это тоже постоянный фильтр, только он не имеет веса, поскольку не влияет на сортировку
  - Принцип плавающих фильтров прост - они постепенно расширяются, тем самым, создавая возможность некоторым тайтлам пройти жестким отбор по близости:
    - Расчитывается шаг расширения для каждого фильтра
    - Запускается цикл:
      - Среди всех тайтлов ищутся тайтлы, отвечающие всем фильтрам(напимер рейтинг больше 7 и меньше 9, дата выхода от 2006 от 2020, кол-во серий от 2 до 7)
      - Если найден хотя бы 1 тайтл, выходим из цикла
      - Расширяем все фильтры на заданный шаг. Например если для рейтинга шаг 0.1, то если на первой итерации фильтр был от 7 до 9, то на второй станет от 6.9 до 9.1
      - Если кол-во итераций превысило `V`, то выходим - рекомендаций подобрать не удалось
  - Данный алгоритм требует некоторых уточнений:
    - Во первых, как подсчитывать шаг? 
      - При большом шаге будут рекомендоваться тайтлы, которые слишком не подходят пользователю. А если взять малй шаг, то жертвуем производительностью. 
      - Нельзя выбрать один и тот же шаг для разных признаков, шаг 0.1 отлично подойдет для рейтинга, а вот для года выпуска совершенно нет
    - Чтобы решить эти проблемы шаг считается следующим способом:
      - Шаг определяется следующим образом: берётся число 's', и к нему прибавляется число 'd' 'd/n-1' раз
      ```
      func LinearF(s, n, d float64) float64 {
        if n == 0 {
            return 0.01
        }
        var square = s
        for i := d; i <= n; i += d {
            square += i
        }
	    return square
      }
      ```
      Принцип прост, в случае если `s = 0, d = 1`, это обычный сумматор всех чисел чисел от 1 до `n`(для 1 = 1, для 2 = 3, для 3 = 6, для 4 = 10). 
        - А теперь представим, что `n` - это вес(дальше я буду называть его `weight`). Видно, что чем больше вес, тем больше полученное значение. При `weight` 1 получим шаг(дальше `step`) 1, а при 10 аж 55! То есть фильтры с наибольшим весом получат наибольший шаг. Получается бред - чем важнее для нас фильтр, тем больше шаг и тем больше лишних тайтлов! Значит `n = weight` - неверно, необходимо брать  `n = 10 - weight` (Считаем, что вес принимает значения от 0 до 10). Отлично, теперь чем больше вес, тем меньше шаг. Например, если у всех параметров, кроме года выпуска поставить вес 9, то у всех фильтров, кроме года будет крайне низкий шаг и в рекомендациях вам выпадут тайтлы, которые не сильно ушли от искомых параметров за исключением года. Однако в этом подходе есть проблема - если пользователь выставит везде вес 10, то получается `step = 0` и никаких рекомендаций не будет. Конечно, пользователь сам стреляет себе в ногу, но давайте облегчим ему боль. Для этого ставится проверка, что если `n == 0`, что `10 - weight == 0`, то шаг `step = 0.01`.
        - Описанный выше способ отлично помогает учитывать веса, но осталась проблема - надо чтобы для разных фильтров можно было генерировать сильно разные шаги(например для одного от 0.01 до 0.1, для другого от 1 до 10). На самом деле это не сложно, надо всего лишь скорректировать подсчёт шага, искуственно понижая или повышая его в K раз. Для этого вводится переменная `denominator`, которая корректирует `weight`. Именно из-за `denominator` приходится вводить переменную `d`, чтобы  инкремент был дробным
        - Оценим значения шага при фиксированных `s = 0, d = 1` и увеличении n: 
          - для 1 -> 1, 
          - для 2 -> 3, 
          - для 3 -> 6, 
          - для 4 -> 10, 
          - для 5 -> 15, 
          - для 6 -> 21, 
          - для 7 -> 28, 
          - для 8 -> 36, 
          - для 9 -> 45, 
          - для 10 -> 55. 

        Рассмотрим `denominator = 50`, мы получим шаг в 50 раз меньше, 1/50, 3/50, 6/50, 10/50, 15/50... 55/50. Если смотреть начиная с 4-го шага, мы видим хорошие шаги, отличные для расширения фильтра оценки тайтла. Но вот до 4-ех шаг крайне маленький. Для этого вводится `s` - стартовое значение. Так, для оценки юзеров это значение равно `0.1`, чтобы искуственно увеличить шаг
    - Уточнение номер 2, а достаточно ли этого шага для расширения?
      - Как я уже говорил, шаг влияет на точность и скорость работы. Благодаря формуле выше, удаётся кастомизировать шаг под свои нужды, то есть сделать его или маленьким для точного подсчёта или большим для подсчёта быстрого. Однако хочется найти золотую середину.       
      Для этого сейчас все шаги специально вычисляются довольно маленькими(если не ставить им малый вес, который заметно повышает шаг). И после каждой `K`-ой операции, шаг умножается на 2! Таким образом получается постепенно ускорять поиск, понижая точность. Я решил выбрать `K = V / 4`, где `V` - количество итераций, после которого будет принять решено, что поиск рекомендаций провалился. 

6. Как учитывается приоритет фильтра при поиске?
- Каждому параметру присваивается некоторый вес, который влияет на то, насколько данный признак влияет на схожесть. По умолчанию установлены следующие веса:
  - Тип тайтла (фильм, сериал, клип и т.д.) - __*1*__
  - Пользовательская оценка (оценка, поставленная пользователями [shikimori](https://shikimori.one/)) - __*1*__
  - Эпизоды (количество серий) - __*3*__
  - ДлительностЬ (хронометраж серии) - __*2*__
  - Возрастной рейтинг (для детей, 13+, 18+, 21+ и т.д.) - __*5*__
  - Год выпуска - __*0.05*__
  - Онгоинг (сезон еще не вышёл на экраны целиком) - __*5*__
  - Студия - __*3*__
  - Жанр - __*10*__
- Чем больше вес у характеристики, тем сильнее разнятся тайтлы с разными вариантами этой характеристики
- Веса постоянных фильтров, веса влияют на порядок вывода - более приоритетные первыми
- Веса плавающих фильтров, помимо ранжирования веса участвуют в определении *близости* тайтла к поисковому запросу

7. Как изменить веса?
-  Нажмите на кнопку "тонкая настройка", она находится правее кнопки "расширенный поиск". При нажатии появятся ползунки для указания весов по каждому признаку. Изменения применятся автоматически